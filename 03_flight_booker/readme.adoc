= GUI 3: Flight Booker

https://github.com/eugenkiss/7guis/wiki#flight-booker[Flight Booker in original 7 GUIs]

image::docs/images/2015-06-29_7guis_03_flight_booker.png[]

== Usage

You can run the application either from the commandline or from the IDE.

=== Commandline

From the commandline in folder _combined_ invoke:

----
./gradlew run
----

=== IntelliJ IDEA

To run it from IntelliJ IDEA simply open _build.gradle_ in the folder _combined_ and then run _ApplicationInMemoryStarter_.

=== Other IDEs

With the proper gradle support/plugins it should also be possible to open the gradle files with Eclipse or Netbeans.
Alternatively you can convert the gradle files to maven pom files.

== How it is done

Let's start again with _Application.java_.
In the previous example the initialization of the presentation models was done by calling the INIT command and then bind the widgets to them in the onFinishedHandler
which is called when the command completes.
In this example (in the bootstrap routine) it is done exactly the same using the CREATE_PMS command.
But in addition, when the binding is done the initialization of the data is also done from the serverside by calling the INIT_DATA command.

Why do we split the initialization process into a CREATE_PMS and an INIT_DATE phase?
Short answer: Because splitting the initilization procedure into two steps makes sure that data changes are properly applied at startup.

Long answer: Data changes happen either when the user changes data in a text widget for example.
This is the obvious way.
But they also happen during the initilization process and this is the problematic case:
when they happen before all bindings are completely set up it is likely that some data changes get lost.
In addition when reasoning about data changes you always have to think through two ways:
changes happening during the initialization process and changes after that during normal application usage.

When the initialization process is split we know for sure after the first phase (CREATE_PMS) that all PMs exist and PM to PM and PM to widget binding is setup completely.
This means in the second phase (INIT_DATA) we can perform data initialization on the server side and it will behave exactly the same as if the user was causing the data changes.
And this makes it much easier to think about the application's data change flow.

The OnFinishedHandler for CREATE_PMS is `MainViewInitializer.initializeBinding`.
Apart from using some helper classes for the widget binding it does not contain any new interesting things.
It simply contains the client side widget binding code.

The OnFinishedHandler for INIT_DATA is `MainViewInitializer.handleDataInitializedEvent`.
TODO: check why code needs to do anything where and why existing binding is not sufficient.

// -------------------------------------------------


On the *serverside* the CREATE_PMS command creates the PM by calling _PMCreator.createPMs()_ and _PMBinder.initializePMBinding()_:

[source,java]
.PMCreator.initializePMBinding()
----
public static void initializePMBinding(ServerDolphin serverDolphin, DomainLogic domainLogic) {

  ServerPresentationModel pm = serverDolphin.getAt(PM_APP);
  bindAttributeTo(pm.getAt(ATT_START_DATE), domainLogic::isDateStringValid, pm.getAt(ATT_START_DATE, VALID_TAG));
  bindAttributeTo(pm.getAt(ATT_RETURN_DATE), domainLogic::isDateStringValid, pm.getAt(ATT_RETURN_DATE, VALID_TAG));

  // Handle change: flightType -> isReturnFlight:
  pm.getAt(ATT_FLIGHT_TYPE).addPropertyChangeListener(PROP_VALUE, evt -> {
    pm.getAt(ATT_RETURN_DATE, Tag.ENABLED).setValue(domainLogic.isReturnFlight(stringValue(pm.getAt(ATT_FLIGHT_TYPE))));
  });

  // Handle change: flightType | startDate | returnDate => BookCommandEnabled
  Arrays.asList(
    pm.getAt(ATT_FLIGHT_TYPE), pm.getAt(ATT_START_DATE), pm.getAt(ATT_RETURN_DATE)
  ).forEach(attr -> attr.addPropertyChangeListener(PROP_VALUE, evt -> evaluateBookCommandEnabled(pm, domainLogic)));
}
----



Note that all this is done on the serverside and the code only deals with the PMs on the serverside.
The code is completly independent from any GUI technology.
But since OpenDolphin shares the presentation model between the server and the client and we have bound the widgets to the PMs on the client the values changed
on the serverside automatically appear on the GUI.


== Conclusion

The keypoint in this example is:

* The presentation model is created on the serverside and in the same step dependent attributes are bound to each other.
For example the dependency of the celsius value on the fahrenheit value (and vice versa) is not implemented on the client side via widgets or PMs
but on the attributes on the serverside. This makes this presentation model reusable. An upcoming HTML GUI just needs to bind it's widgets to the PM
and is done.

In the next blog post we will look at the *Flight Booker*.

== TODO

* describe okAttribute
